/**
 * Utilities.
 */

/**
 * A for-loop implementation - seems to work for number ranges but not lists.
 * WIP.
 *
 * @see https://github.com/seven-phases-max/less.curious/blob/master/src/for.less
 */

.yr-for-(@i, @n) {
    .-each(@i);
}

.yr-for-(@n) when (isnumber(@n)) {
    .yr-for-(1, @n);
}

.yr-for-(@i, @n) when not (@i = @n)  {
    .yr-for-((@i + (@n - @i) / abs(@n - @i)), @n);
}

/**
 * Simple pseudo-random.
 */

.yr-rand(@seed: 123456) {
    @r: sin(@seed) * 123456;
    @rand: @r - floor(@r);
}


/**
 * A way to use the media query selectors.
 *
 * @example `.yr-m-(~'only screen and @{yr-mq-s-m}'); .-q() {...}`
 */

.yr-m-(@query) {
    @media @query {
        .-q();
    }
}


/**
 * Convenience for toggling a global or local flag.
 * Override controls whether we'll do the long expansion bt default.
 *
 * This will enable the contents when `.flag` is present at or above the element scope:
 * `.yr-on-(~'.flag'); .-do() {...}`
 * Becomes `&.flag, .flag & {...}`, if `@override` is `true`.
 * Or simply `.flag & {...}`, if `@override` is `false`.
 * 
 * 
 * @note The scoping's a little funny here, to closure the mixin callback scope:
 *       `& { .yr-on-(...); .-do() {...}}` keeps `.-do` in a closure.
 *       `.yr-on-(...); .-do() {...}` leaves `.-do` out in local scope.
 */

@yr-on-override: false;

.yr-on-(@flag, @override: @yr-on-override) when (@override = true) {
    &@{flag},
    @{flag} & {
        .-do();
    }
}
.yr-on-(@flag, @override: @yr-on-override) when (@override = false) {
    @{flag} & {
        .-do();
    }
}


/**
 * Fancy link styling.
 */

.yr-a() {
    .tweak-yr-a-style-fancy & {
        position: relative;
        display: inline-block;
        border: 0 solid currentColor;
        text-decoration: none;
        z-index: 1;

        &[target="_blank"] {
            border-style: dashed;
        }

        &::before {
            content: '';
            position: absolute;
            display: block;
            border: inherit;
            z-index: -1;

            @x: -2px;
            left: @x;
            right: @x;
            bottom: 0;
            border-bottom-width: 1px;
            pointer-events: none;
            .transform-origin(bottom);
            will-change: transform, opacity, border-color;
            .transition(transform 500ms ease-out,
                opacity 500ms ease-out,
                border-color 500ms ease-out;);
        }

        &:visited::before {
            opacity: 0.33;
        }

        &:hover,
        &:focus,
        &:active {
            &::before {
                .transition(transform 200ms ease-out,
                    opacity 300ms ease-out,
                    border-color 300ms ease-out;);
            }
        }

        &:hover,
        &:focus {
            &::before {
                .transform(scaleY(@tweak-yr-a-style-fancy-scale));
                opacity: 0.25;
            }
        }

        &:active::before {
            .transform(scaleY(0));
        }

        &:empty::before {
            left: 0;
            right: 0;
        }
    }
}


/**
 * Loader animation styling.
 */

@yr-loader-fade-const: false;

/**
 * The base animation, for both `simple` and `fancy` loader animations.
 * @param {Boolean} @const Whether the animation rules should be scoped to only affect when
 *                        a load is happening; `true` if it can be applied all the time
 *                        (maybe smoother animation); `false` if it should be kept temporary
 *                        (less conflict with the element's normal state).
 */

.yr-loader-fade(@const: @yr-loader-fade-const) when (@const = false) {
    [data-yr-ajax-loading] & {
        .yr-loader-fade(true);
    }
}
.yr-loader-fade(@const: @yr-loader-fade-const) when (@const = true) {
    will-change: transform, opacity;
    @transition: transform @yr-loader-fade-time @yr-ease-far-out,
        opacity @yr-loader-fade-time @yr-ease-far-out;
    .transition(@transition);
}
.yr-loader-fade(@_: _) {
    [data-yr-ajax-loading="navigate"] &,
    [data-yr-ajax-loading="unload"] & ,
    [data-yr-ajax-loading="swap"] & {
        /* Hide. */
        opacity: 0;
        .transform(translateY(@tweak-yr-loader-fade-content-move)
            scale(@tweak-yr-loader-fade-content-scale););
    }

    [data-yr-ajax-loading="navigate"] &,
    [data-yr-ajax-loading="unload"] & {
        @transition: transform @yr-loader-fade-time @yr-ease-far-in,
            opacity @yr-loader-fade-time @yr-ease-far-in;
        .transition(@transition);
    }

    [data-yr-ajax-loading="swap"] & {
        /* Instant swap so we transition back in cleanly. */
        .transition(none);
    }
}

/**
 * Random-ish timing offsets.
 */

.yr-loader-fade-stagger-inner(@n: 1, @seed: 123) when (@n > 1) {
    .yr-for-(@n); .-each(@i) {
        &:nth-child((~'@{n}n+@{i}')) {
            .yr-loader-fade-stagger-rand(@n + @i + @seed);
        }
    }
}
.yr-loader-fade-stagger-inner(@n: 1, @seed: 123) when (@n < 2) {
    .yr-loader-fade-stagger-rand(@n + @seed);
}

.yr-loader-fade-stagger-rand(@seed: 123) {
    // Returns `@rand`.
    .yr-rand(@seed);
    @stagger: @rand * @yr-loader-fade-time;

    [data-yr-ajax-loading] & {
        /* Fade out quickly. */
        .transition-delay(@stagger);
    }

    [data-yr-ajax-loading="load"] & {
        /* How long the parent has to do its animation in before the children do. */
        .transition-delay(@yr-loader-fade-time + @stagger);
    }
}

.yr-loader-fade-stagger-outer() {
    [data-yr-ajax-loading] & {
        /* How long the children have to do their animations out before the parent does. */
        .transition-delay(@yr-loader-fade-time * 2);
    }

    [data-yr-ajax-loading="load"] & {
        /* Fade in quickly. */
        .transition-delay(0ms);
    }
}


/**
 * Aliases.
 */

.display(@display) when (@display = flex) {
    .flex-block();
}
.display(@display) when (@display = inline-flex) {
    .flex-inline();
}
